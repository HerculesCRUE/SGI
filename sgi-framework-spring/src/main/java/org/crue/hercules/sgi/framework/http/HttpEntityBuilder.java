package org.crue.hercules.sgi.framework.http;

import java.util.Arrays;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;

import javax.servlet.http.HttpServletRequest;

import org.crue.hercules.sgi.framework.spring.context.support.ApplicationContextSupport;
import org.crue.hercules.sgi.framework.web.config.OAuth2ClientConfiguration;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.data.util.Optionals;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.security.oauth2.client.AuthorizedClientServiceOAuth2AuthorizedClientManager;
import org.springframework.security.oauth2.client.OAuth2AuthorizeRequest;
import org.springframework.security.oauth2.client.OAuth2AuthorizedClient;
import org.springframework.security.oauth2.core.OAuth2AccessToken;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import lombok.extern.slf4j.Slf4j;

/**
 * Utility class for building a {@link HttpEntity}. The HttpEntity would contain
 * the Authorization header from current HTTP Request, if
 * withCurrentUserAuthorization() method is used or an Authorization header with
 * the Bearer token generated by
 * {@link AuthorizedClientServiceOAuth2AuthorizedClientManager} for the given
 * clientRegistrationId if withClientAuthorization(String clientRegistrationId)
 * is used.
 * 
 * @see OAuth2ClientConfiguration
 */
@Slf4j
public class HttpEntityBuilder<T> {
  private T entity;
  private HttpHeaders headers;
  private String clientRegistrationId;
  private boolean useCurrentUserAuthorization = false;

  /**
   * Creates a new {@link HttpEntityBuilder} for building an {@link HttpEntity}
   * containing the provided Entity.
   * 
   * @param entity the entity
   */
  public HttpEntityBuilder(T entity) {
    this.entity = entity;
  }

  /**
   * Creates a new {@link HttpEntityBuilder} for building an {@link HttpEntity}.
   */
  public HttpEntityBuilder() {
  }

  /**
   * Sets the Entity to include in the {@link HttpEntity}.
   * 
   * @param entity the entity
   * @return self reference
   */
  public HttpEntityBuilder<T> withEntity(T entity) {
    this.entity = entity;
    return this;
  }

  /**
   * Sets the clientRegistrationId to include in the {@link HttpEntity}.
   * 
   * @param clientRegistrationId the Oauth2 client registration id
   * @return self reference
   */
  public HttpEntityBuilder<T> withClientAuthorization(String clientRegistrationId) {
    this.clientRegistrationId = clientRegistrationId;
    return this;
  }

  /**
   * Allow to re-use the current HTTP Request Authorization header in the
   * {@link HttpEntity}.
   * 
   * @return self reference
   */
  public HttpEntityBuilder<T> withCurrentUserAuthorization() {
    this.useCurrentUserAuthorization = true;
    return this;
  }

  /**
   * Sets extra {@link HttpHeaders} to include in the {@link HttpEntity}.
   * 
   * @param headers {@link HttpHeaders} to include
   * @return self reference
   */
  public HttpEntityBuilder<T> withHeaders(HttpHeaders headers) {
    this.headers = headers;
    return this;
  }

  /**
   * Builds the {@link HttpEntity} with the provided information.
   * 
   * @return the {@link HttpEntity}
   */
  public HttpEntity<T> build() {
    headers = (headers != null ? headers : new HttpHeaders());
    headers.setContentType(MediaType.APPLICATION_JSON);
    headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN, MediaType.TEXT_HTML));
    headers.setAcceptLanguage(Arrays.asList(new Locale.LanguageRange(LocaleContextHolder.getLocale().toLanguageTag())));

    if (useCurrentUserAuthorization) {
      withCurrentUserAuthorization(headers);
    }

    if (clientRegistrationId != null) {
      withClientCredentials(headers, clientRegistrationId);
    }
    return new HttpEntity<>(entity, headers);
  }

  private static void withCurrentUserAuthorization(HttpHeaders headers) {
    // Use Authorization from caller
    Optional<HttpServletRequest> req = getCurrentHttpRequest();
    if (req.isPresent()) {
      HttpServletRequest httpServletRequest = req.get();
      String authorization = httpServletRequest.getHeader(HttpHeaders.AUTHORIZATION);
      if (authorization != null) {
        headers.set(HttpHeaders.AUTHORIZATION, authorization);
      } else {
        log.warn("Can't get current user Authorization.");
      }
    } else {
      log.warn("Can't get current user Authorization. Not running in an HttpRequest.");
    }
  }

  private static void withClientCredentials(HttpHeaders headers, String clientRegistrationId) {
    // Use client credentials
    Optional<AuthorizedClientServiceOAuth2AuthorizedClientManager> manager = getAuthorizedClientServiceOAuth2AuthorizedClientManager();
    Optionals.ifPresentOrElse(manager,
        (AuthorizedClientServiceOAuth2AuthorizedClientManager authorizedClientServiceAndManager) -> {
          // Build an OAuth2 request for the Keycloak provider
          OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest
              .withClientRegistrationId(clientRegistrationId).principal(clientRegistrationId).build();

          // Perform the actual authorization request using the authorized client service
          // and authorized client manager. This is where the JWT is retrieved from the
          // Keycloack servers.
          OAuth2AuthorizedClient authorizedClient = authorizedClientServiceAndManager.authorize(authorizeRequest);

          if (authorizedClient != null) {
            // Get the token from the authorized client object
            OAuth2AccessToken accessToken = Objects.requireNonNull(authorizedClient).getAccessToken();

            String authorization = "Bearer " + accessToken.getTokenValue();
            headers.set(HttpHeaders.AUTHORIZATION, authorization);
          } else {
            log.warn("Can't get client Authorization.");
          }
        }, () -> log.warn(
            "Can't get client Authorization."));
  }

  private static Optional<HttpServletRequest> getCurrentHttpRequest() {
    return Optional.ofNullable(RequestContextHolder.getRequestAttributes())
        .filter(ServletRequestAttributes.class::isInstance).map(ServletRequestAttributes.class::cast)
        .map(ServletRequestAttributes::getRequest);
  }

  private static Optional<AuthorizedClientServiceOAuth2AuthorizedClientManager> getAuthorizedClientServiceOAuth2AuthorizedClientManager() {
    AuthorizedClientServiceOAuth2AuthorizedClientManager authorizedClientServiceOAuth2AuthorizedClientManager = null;
    try {
      authorizedClientServiceOAuth2AuthorizedClientManager = ApplicationContextSupport.getApplicationContext()
          .getBean(AuthorizedClientServiceOAuth2AuthorizedClientManager.class);
    } catch (NoSuchBeanDefinitionException e) {
      log.warn("No AuthorizedClientServiceOAuth2AuthorizedClientManager bean found.", e);
    }
    return Optional.ofNullable(authorizedClientServiceOAuth2AuthorizedClientManager);
  }
}
